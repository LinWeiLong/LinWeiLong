<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="标签">
<meta property="og:url" content="http://yoursite.com/tags/index.html">
<meta property="og:site_name" content="Willong&#39;s Blog">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-01-25T17:51:17.531Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="标签">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.0.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/tags/">





  <title>Willong's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Willong's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/23/js-prototype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Willong lin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/23/js-prototype/" itemprop="url">JS的原型是什么鬼？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-23T22:43:09+08:00">2020-02-23</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>其实作为一个入行那么久的前端，不应该在这时候才来写这种文章了。不过既然之前没写，今天就来总计一下。</p>
<p>在说原型之前，得先说一下JS关于继承的实现。其实JS的继承跟其他Java或者C++等面向对象实现的继承不一样，JS的继承是通过原型的继承来实现的。也就是说JS的继承是另一种方法。</p>
<p>提到JS的原型，及绕不开三个概念：</p>
<ul>
<li>constructor/构造函数,</li>
<li>prototype/原型,</li>
<li><em>proto</em>/原型链。</li>
</ul>
<h1 id="constructor-构造函数（实例生产者）"><a href="#constructor-构造函数（实例生产者）" class="headerlink" title="constructor 构造函数（实例生产者）"></a>constructor 构造函数（实例生产者）</h1><p>构造函数，概念跟面向对象的构造函数一个概念。粗略地说就是“用来产生实例的函数。”每个类都会有一个构造函数。</p>
<p>而在JS当中，所有的函数都是构造函数，只要当它跟<code>new</code>关键字一起使用时，就起到了构造函数的作用。</p>
<h1 id="prototype-原型（模板）"><a href="#prototype-原型（模板）" class="headerlink" title="prototype 原型（模板）"></a>prototype 原型（模板）</h1><p>prototype 是每个构造函数产生的时候都会同时产生的一个对象，里面有 constructor 属性，指向函数本身，而函数本身也会有一个prototype属性指向prototype。</p>
<p>我个人理解，用通俗的说法就行，每个函数的产生，都会有一个对应的数据结构产生，这个东西就叫prototype（原型），相当于一个模板。每次new一个实例的时候，都会从这个原型上进行一次copy，然后将复制体返回给外面。</p>
<p>所以，当我们在某个function的prototype上挂载方法或者属性时，我们实际上是修改了这个“类”（为了方便理解姑且这么叫吧）的模板。那既然模板都被修改了，所以所有生产出来的实例都会跟着变化啦！</p>
<h1 id="proto-原型链-模板是谁"><a href="#proto-原型链-模板是谁" class="headerlink" title="__proto__  原型链(模板是谁)"></a>__proto__  原型链(模板是谁)</h1><p>既然知道了原型，那这个原型链又是什么东西？</p>
<p>原型链属于实例(相对应的，实例是没有prototype的，只有构造函数才有)，用于指向这个实例的构造函数的原型。如果画一个图的话，那么我觉得这个<strong>proto</strong>可以作为一条线，然后连接实例和它的构造函数的prototype。</p>
<p>也正是有了<strong>proto</strong>，实例才能够使用prototype上面的属性和方法，否则实例的成员只包含构造函数内声明的属性或者方法。</p>
<hr>
<p>其实概念就这么简单。只要将上面的几个概念记牢了，面试时面对一些提问的方法，加以套用就能答出正解。</p>
<h1 id="todo-补充一些变体问题"><a href="#todo-补充一些变体问题" class="headerlink" title="todo 补充一些变体问题"></a>todo 补充一些变体问题</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/26/interview-yy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Willong lin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/26/interview-yy/" itemprop="url">面试记@YY</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-26T00:48:17+08:00">2020-01-26</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于放假前收到YY电商部门的面试邀请，抱着试一试的心态接收了面试邀请。最终结果应该是凉凉了，但是还是有所得，趁着过年期间进行一下总结。</p>
<h3 id="一面：技术面"><a href="#一面：技术面" class="headerlink" title="一面：技术面"></a>一面：技术面</h3><p>是两位前端技术人员进行面试，此时气氛比较轻松，聊到的东西也比较广，有几个问题比较深刻。</p>
<ol>
<li><p>因为简历上写到一个Git的子模块的使用，询问了一下子模块的使用，Git的工作流，为什么不用私有npm（其实后来有搭）</p>
</li>
<li><p>现在有一个类似webpack那样的项目（我的解读是有一个核心功能+各种loader/plugin），会怎么对这个项目进行代码管理？</p>
<ol>
<li>目录怎样划分？</li>
<li>内置的一些功能（loader/plugin）怎么划分？</li>
</ol>
</li>
<li><p>如果有一个大型项目（类似内部到处用的脚手架那种），如果这个大包的线上版本有问题，其所依赖的一个包是有问题的，怎么去解决这个问题？我的回答是，这个项目在设计之初，就要提供一个“自检”的阶段</p>
</li>
<li><p>说一下VUE的特性，双向绑定的原理（粗略带过），提到Object.defineProperity，依赖收集等等，其实是比较含糊的</p>
</li>
<li><p>socket和websocket是一样吗？（直接说不清楚，大概说了一下是长连接），还提了一下Web-CRT是什么，跟web-socket有啥不一样？</p>
</li>
<li><p>提到了一个之前被DNS劫持的，怎么解决的。页面被嵌套iframe。展开发问，遇到DNS劫持，有什么办法解决。</p>
</li>
<li><p>http 1.0、1.1、2.0 之间的区别？</p>
</li>
<li><p>有一个实时性需要很高且很高并发的列表，在node-SSR的项目中，怎么维持这个列表的实施性？</p>
</li>
</ol>
<h3 id="二面：技术面（组长-负责人-面）"><a href="#二面：技术面（组长-负责人-面）" class="headerlink" title="二面：技术面（组长/负责人 面）"></a>二面：技术面（组长/负责人 面）</h3><ol>
<li>VUE 的双向绑定怎么实现，需要非常详细说，整个源码级别的理解。<ol>
<li>依赖收集是怎么实现的</li>
<li>动态化</li>
</ol>
</li>
<li>Vue的生命周期，只是简单地说了有那些周期，没有述说他们的区别，也是做得不够好的地方。</li>
<li>画出构造函数+原型之间+实例的关系。关于原型链的一个普通问题，没有答出来，其实很不应该。</li>
<li>从2展开的一个问题，有一个A的function（内含一个字段+一个方法），现在B想要继承A，直接functionB去call一下A。同样要求描述一下B跟题目2中间的关系链条，也是没有答出来</li>
<li>说一下对docker的了解</li>
</ol>
<h3 id="三面：HR面"><a href="#三面：HR面" class="headerlink" title="三面：HR面"></a>三面：HR面</h3><ol>
<li>为什么想离开原有的公司？</li>
<li>觉得自己是一个怎样的人？</li>
<li>希望去到一个怎样的环境/团队？</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>http 各个版本的区别确实基本上等于空白，只知道http协议的请求头+请求体，缓存控制字段</li>
<li>Vue的原理不够清晰，表达含糊</li>
<li>JS的原型和构造函数等几个之间的关系</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/26/dart-startup/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Willong lin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/26/dart-startup/" itemprop="url">Dart语言入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-26T23:54:19+08:00">2019-12-26</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前在微信文章评论点赞收到了一本Flutter入门与实战，于是以此为契机来学习一把Flutter的技术栈。这篇文章主要是介绍Dart语言的一些基本语法。</p>
<h1 id="1-变量与基本数据类型"><a href="#1-变量与基本数据类型" class="headerlink" title="1. 变量与基本数据类型"></a>1. 变量与基本数据类型</h1><p>声明操作：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">'小明'</span>;`</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name2 <span class="comment">// 未赋值默认值是null</span></span><br><span class="line"><span class="keyword">if</span>(name2 == <span class="keyword">null</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="1-1-常量和固定值"><a href="#1-1-常量和固定值" class="headerlink" title="1.1 常量和固定值"></a>1.1 常量和固定值</h2><p>以 <code>final</code> <code>const</code> 关键字声明：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> username = <span class="string">'张三'</span>; <span class="comment">// final 的值只能被设定一次</span></span><br><span class="line">username = <span class="string">'李四'</span>; <span class="comment">// 会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="keyword">const</span> area = pi*<span class="number">100</span>*<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> stars = <span class="keyword">const</span> []; <span class="comment">// const 关键字可以作为构造函数创建常量</span></span><br><span class="line"><span class="keyword">const</span> buttons = <span class="keyword">const</span> [];</span><br></pre></td></tr></table></figure>

<h2 id="1-2-基本数据类型"><a href="#1-2-基本数据类型" class="headerlink" title="1.2 基本数据类型"></a>1.2 基本数据类型</h2><p>Dart 常用基本数据类型包括：Number、String、Boolean、List、Map</p>
<h3 id="1-2-1-Number类型"><a href="#1-2-1-Number类型" class="headerlink" title="1.2.1 Number类型"></a>1.2.1 Number类型</h3><p>Number下面还包括int（整型）和double（浮点）</p>
<ul>
<li>整型：取值范围-2^53 ~ 2^53</li>
<li>浮点型：64为长度的浮点型数据，双精度浮点型</li>
</ul>
<p>基本操作四则运算（+ - * /）和位移操作 &gt;&gt;.</p>
<p>常用方法：abs、ceil、floot。</p>
<h3 id="1-2-2-String-类型"><a href="#1-2-2-String-类型" class="headerlink" title="1.2.2 String 类型"></a>1.2.2 String 类型</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'字符串哈哈哈'</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">"双引号也行"</span></span><br><span class="line"><span class="keyword">var</span> str3 = str +str2 <span class="comment">// 合并字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multi_line_string1 = <span class="string">'''这个是一个</span></span><br><span class="line"><span class="string">多行的</span></span><br><span class="line"><span class="string">文本</span></span><br><span class="line"><span class="string">类似</span></span><br><span class="line"><span class="string">JS的 ``'''</span></span><br><span class="line"><span class="keyword">var</span> multi_line_string1 = <span class="string">"""这个是一个</span></span><br><span class="line"><span class="string">双引号</span></span><br><span class="line"><span class="string">也</span></span><br><span class="line"><span class="string">可以"""</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-Boolean-类型"><a href="#1-2-3-Boolean-类型" class="headerlink" title="1.2.3 Boolean 类型"></a>1.2.3 Boolean 类型</h3><p>Boolean 是true or flase 的类型。在Dart当中，没有隐式转换，只有真的是true的bool类型才是这真的 true。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sex = <span class="string">'male'</span></span><br><span class="line"><span class="keyword">if</span>(sex) &#123; <span class="comment">// 实际上在编译的时候会报类型错误</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'this people is a man'</span>) <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-List-类型"><a href="#1-2-4-List-类型" class="headerlink" title="1.2.4 List 类型"></a>1.2.4 List 类型</h3><p>具有一系列相同类型的数据，称为List对象。类似于JS中的Array（不过JS的Array没要求内容一定要一样就是了）。索引那些也都一样，不多说了。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">print</span>(list1.length); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">print</span>(list1[<span class="number">0</span>]); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/10/algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Willong lin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/10/algorithm/" itemprop="url">算法学习之题目记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-10T23:25:45+08:00">2019-10-10</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="开坑声明"><a href="#开坑声明" class="headerlink" title="开坑声明"></a>开坑声明</h1><p>之前买了极客时间的一个《算法面试通关40讲》的课程，里面有提到的题目，打算以笔记的形式记录下来，一个题目的思考分析过程和自己的实现结果。</p>
<p>废话不多说，马上开始。</p>
<hr>
<h1 id="第一题：链表反转"><a href="#第一题：链表反转" class="headerlink" title="第一题：链表反转"></a>第一题：链表反转</h1><p>题目描述：反转一个<strong>有序</strong>单链表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>像视频里面说的，链表的这个题目思路或者说肉眼看上去就感觉比较简单。就是将链表里面的指针都反转一次。</p>
<p>步骤细化：</p>
<ol>
<li>将大问题分成若干个小问题，整个链表的反转，实际上是每一个链表节点的next指针从本来指向的元素改成上一个元素。</li>
<li>替换指针，<ol>
<li>理解当前节点cur、当前节点的上一个节点prev、当前节点的下一个节点nextNode，三个概念和对应的临时变量</li>
<li>先将cur的next存起来，准备推进流程用</li>
<li>修改cur.next = prev</li>
<li>prev 已经被用掉了，所以要更新 prev = cur，当前节点变成了别人的prev</li>
<li>最后更新cur = 第2步存的nextNode，将原来的下一个节点推为新的cur</li>
</ol>
</li>
<li>边界情况，当前节点没有next指针了</li>
</ol>
<p>实际上我自己写的时候，是有问题的，没有用到prev这个临时变量去存储上一个的指针，自以为JS的引用类型，直接将cur和nextNode的next递归去修改，也没想着利用最后一个节点必然是null的情况去去占位prev。</p>
<p>下面是我在力扣上提交的代码，还有改进的空间。现在用的是while写的，还可以用递归去写一个版本，看下这周有没有时间去做。</p>
<h2 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初次成功版</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// if(head.next === null) &#123;</span></span><br><span class="line">    <span class="comment">//     // handle too short</span></span><br><span class="line">    <span class="comment">//     return head</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>,</span><br><span class="line">        cur = head,</span><br><span class="line">        nextNum,</span><br><span class="line">        temp</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        nextNum = cur.next</span><br><span class="line">        cur.next = prev</span><br><span class="line">        prev = cur</span><br><span class="line">        cur = nextNum</span><br><span class="line">        nextNum = nextNum? nextNum.next: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">reverseList()</span><br></pre></td></tr></table></figure>

<center>----- 第一题：链表反转 到此结束 -----</center>

<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/08/what-is-docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Willong lin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/08/what-is-docker/" itemprop="url">从前端角度学Docker</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-08T17:11:06+08:00">2019-10-08</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、什么是Docker？"><a href="#一、什么是Docker？" class="headerlink" title="一、什么是Docker？"></a>一、什么是Docker？</h1><h2 id="1-1-Docker这件事的前世今生-Docker解决了什么问题-？"><a href="#1-1-Docker这件事的前世今生-Docker解决了什么问题-？" class="headerlink" title="1.1 Docker这件事的前世今生 / Docker解决了什么问题 ？"></a>1.1 Docker这件事的前世今生 / Docker解决了什么问题 ？</h2><p>要搞清楚Docker是什么东西，最简单的切入点，就是了解他解决了什么问题，如果一个东西没有解决任何问题，那么我们肯定没有理解和学习它的必要。那么Docker现在这么火，倒推过来，就表示Docker解决了很多人的痛点！</p>
<p><em>那么Docker解决了什么痛点呢？</em></p>
<p>就是软件开发当中的环境配置问题，学习软件开发的第一节课，可能都是如何配置XXX语言的运行环境，XXX框架的开发环境。这还是开发阶段的，以前在开发阶段没问题，去到部署的时候可能有问题，这种就是开发机和线上机的环境不一致造成的。为了维持软件运行环境所安装的软件依赖的一致性，给开发人员造成了很大的工作量。后来开发人员就希望要是能够保持环境的依赖一直一样就好了。于是出现了第一代方案：</p>
<h3 id="1-1-1-虚拟机"><a href="#1-1-1-虚拟机" class="headerlink" title="1.1.1 虚拟机"></a>1.1.1 虚拟机</h3><p>虚拟机，就是在一台机器上再将资源分配划分为另一台机器。虚拟机以文件的形式存在于底层（物理）机器的操作系统上。虽然虚拟机可以通过以文件的形式承载一整个操作系统，也就解决了环境依赖的问题，但是虚拟机也有很大的缺点，就是：</p>
<ol>
<li>占资源多</li>
<li>冗余步骤多，因为每次部署虚拟机都需要搞一次操作系统</li>
<li>启动慢</li>
</ol>
<p>为了某个软件使用虚拟机方案，其实里面的系统就是这个方案的”副作用“。那么，能不能没有系统这一层副作用呢？答案是有的，就是Linux容器技术。</p>
<h3 id="1-1-2-Linux容器"><a href="#1-1-2-Linux容器" class="headerlink" title="1.1.2 Linux容器"></a>1.1.2 Linux容器</h3><p>Linux容器（Linux Containers， AKA LXC）。<br>Linux容器不模拟一个完整的操作系统，只是对进程进行隔离。在容器里的进程，接触的系统资源都是被虚拟处理过的，类似做了一层物理资源的保护层，进行隔离。这样的操作是进程级别，相比虚拟机具备了其不具备的优点：</p>
<ol>
<li>资源占用少</li>
<li>启动快</li>
<li>体积小</li>
</ol>
<p>容器相当于进程级别的虚拟机，同样对系统资源进行虚拟化，但是没了操作系统这个拖油瓶，速度快了很多。</p>
<h3 id="1-2-Docker是什么？"><a href="#1-2-Docker是什么？" class="headerlink" title="1.2 Docker是什么？"></a>1.2 Docker是什么？</h3><p>Docker是基于Linux容器的一种封装，提供简单易用的容器使用接口。是目前最流行的Linux容器解决方案。</p>
<blockquote>
<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>
<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
</blockquote>
<h1 id="二、为什么要学习Docker？"><a href="#二、为什么要学习Docker？" class="headerlink" title="二、为什么要学习Docker？"></a>二、为什么要学习Docker？</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/03/http-cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Willong lin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/03/http-cache/" itemprop="url">http协议的缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-03T11:52:48+08:00">2019-10-03</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前一次面试被问到这方面的问题，对这方面进行了一次整理。废话不多说，直接列大纲。</p>
<ol>
<li>前提：HTTP结构</li>
<li>缓存规则</li>
<li>缓存类型</li>
<li>强制缓存</li>
<li>对比缓存</li>
</ol>
<h1 id="前提：HTTP结构"><a href="#前提：HTTP结构" class="headerlink" title="前提：HTTP结构"></a>前提：HTTP结构</h1><p>HTTP请求，由请求头和请求体部分，请求体就是请求返回的我们要用的东西，请求头就是一些类似于配置的信息。</p>
<h1 id="缓存规则-流程"><a href="#缓存规则-流程" class="headerlink" title="缓存规则/流程"></a>缓存规则/流程</h1><p>浏览器内部有一个管理缓存的地方和对应的流程和规则，先按照网上的说法定义为浏览器的缓存数据库。</p>
<p>初次请求的时候，查询数据库，数据库返回没有数据，浏览器发起请求给浏览器，浏览器返回数据，将数据和缓存规则写入缓存系统<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7l4q33x3xj30b7091gm6.jpg" alt="初次请求"></p>
<p>下面是查询缓存数据库的时候发现强缓存规则时调用的规则和没有命中强缓存规则的流程。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7l4tgga10j30o1098q42.jpg" alt="强缓存规则"></p>
<p>下面是查询缓存数据库的时候发现对比缓存规则时调用的规则和没有命中强缓存规则的流程。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7l4xt1egtj30qb09g75u.jpg" alt="对比缓存规则"></p>
<ol>
<li>发起请求，查询缓存仓库<ol>
<li>有缓存，查询是否过期</li>
<li>没有缓存，发起请求，</li>
</ol>
</li>
<li>查询缓存是否过期<ol>
<li>没过期，走强制缓存路线</li>
<li>已经过期，查Etag</li>
</ol>
</li>
<li>Etag是否匹配<ol>
<li>过期了</li>
</ol>
</li>
</ol>
<h1 id="缓存类型："><a href="#缓存类型：" class="headerlink" title="缓存类型："></a>缓存类型：</h1><ul>
<li>强制缓存<ul>
<li>cache-control</li>
<li>expires</li>
</ul>
</li>
<li>对比缓存<ul>
<li>last-Modified/If-Modified-Since</li>
<li>Etag/if-None-Match</li>
</ul>
</li>
</ul>
<h1 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h1><p>强制缓存通过http请求的header部分标识，分别是Expires字段和Cache-control字段，下面来介绍一下这两者的作用。</p>
<h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><p>Expires标识服务端返回的到期时间，在这个到期时间之前，资源都可以使用缓存，不用再问服务端索取。</p>
<p>Expires属性属于HTTP1.0的属性，现在浏览器默认都是HTTP1.1版本的协议，所以作用基本上已经可以忽略不计。</p>
<p>另外就是Expires的时间是服务器时间，如果客户端的时间跟服务端时间不同步，那么Expires基本上就跪了。比如我把电脑上的时间设置成10年后，那么无论我发送什么请求，都是缓存不了的，因为在我的客户端看来所有资源都是过期的。</p>
<h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p>Cache-Control是强制缓存当前最常用的属性。上面说到Expires的服务器时间引起的过期问题，那就是说绝对时间不行，所以Cache-Control就改进了这一点，使用了相对时间。</p>
<p>Cache-Control的属性：</p>
<ul>
<li>private：客户端可以缓存</li>
<li>public：客户端和代理服务器都可以缓存</li>
<li>max-age=xxx：资源在xxx秒后失效</li>
<li>no-cache：使用<em>对比缓存</em>来验证缓存数据</li>
<li>no-store：所有内容都不进行任何形式的缓存</li>
</ul>
<h1 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h1><p>什么是对比缓存：需要进行比较判断是否可以使用缓存。通俗地说，就是问下服务器，我能不能使用我本地的这一份缓存，如果可以就返回个304，不行就返回个200.</p>
<p>那问题来了，怎么去做这个问一下服务器的事情呢？主要就是依赖 Last-Modified/If-Modified-Since，E-tag/if-None-Match，这两块属性。</p>
<h2 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h2><p>Last-Modified(返回)：是服务器告诉浏览器，这个资源最后的修改时间。下次浏览器请求同一个资源的时候，会将这个资源的Last-Modified用If-Modified-Since的字段告诉服务器，服务器通过对比这个资源的最后修改时间，如果还是在Last-Modified的那个时间，那么就返回304告诉浏览器使用缓存。</p>
<p>If-Modified-Since（带过去）：告诉服务器，服务器返回的资源最后的修改时间。</p>
<h2 id="E-tag-If-None-Match"><a href="#E-tag-If-None-Match" class="headerlink" title="E-tag/If-None-Match"></a>E-tag/If-None-Match</h2><p>E-tag（返回）：服务器响应的时候，告诉浏览器在副武器的唯一标识，标识的生成规则由服务器决定。</p>
<p>If-None-Match（带过去）：请求服务器时，以If-None-Match将E-tag的内容带过去。服务器收到If-None-Match的字段之后，对服务器资源进行标识比对，如果没有匹配的话，则返回200，有匹配的话就返回304.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/how-vue-work/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Willong lin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/how-vue-work/" itemprop="url">how-vue-work</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-28T23:48:47+08:00">2019-08-28</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/eventloop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Willong lin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/eventloop/" itemprop="url">JS中的setTimeout和promise是怎么回事？详解event loop机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-28T22:19:01+08:00">2019-08-28</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在说内容之前，先发一道面试题，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例题1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure>

<p>这个题目比较简单，应该能够看出来结果是：script start -&gt; script end -&gt; promise1 -&gt; promise2 -&gt; setTimeout</p>
<p>那为什么是这个顺序呢，结合一些网上的文章，我尝试用自己的理解或者说法去记录这个知识点。</p>
<h1 id="浏览器内核渲染进程介绍"><a href="#浏览器内核渲染进程介绍" class="headerlink" title="浏览器内核渲染进程介绍"></a>浏览器内核渲染进程介绍</h1><p>在浏览器的每一个Tab，都被认为是一个渲染进程，渲染进程内部分为多个线程，这多个线程之间相合作，各自管理着各自专注的领域的事情：</p>
<ol>
<li>GUI渲染线程<ul>
<li>渲染页面，计算布局和绘制样式</li>
<li>重绘和回流时会执行</li>
<li>和JS引擎线程互斥 （防止结果混乱不可预期）</li>
</ul>
</li>
<li>JS引擎线程<ul>
<li>解析和执行JS代码</li>
<li>单线程</li>
<li>和GUI渲染互斥（防止结果混乱不可预期）</li>
</ul>
</li>
<li>事件触发线程<ul>
<li>管理事件的循环，鼠标点击/滚动、setTimeout、ajax</li>
<li>在达到条件时，将回调方法放入JS引擎的执行队列</li>
</ul>
</li>
<li>定时器触发线程<ul>
<li>setTimeout和setInterval的管理线程</li>
<li>定时任务由定时器触发线程计时（如果定时器不多的页面，这个线程岂不是很空闲）</li>
<li>当计时完毕，通知事件触发线程</li>
</ul>
</li>
<li>异步http请求线程<ul>
<li>发起和处理异步请求的线程</li>
<li>当请求完成，有回调时，通知事件触发线程干活</li>
</ul>
</li>
</ol>
<h1 id="Event-loop机制介绍"><a href="#Event-loop机制介绍" class="headerlink" title="Event loop机制介绍"></a>Event loop机制介绍</h1><p><img src="http://ww3.sinaimg.cn/large/006y8mN6gy1g6frdhv7ecj30k00bmmxw.jpg" alt="Eventloop 介绍"></p>
<p>首先我们要明确一个点，JS是从上而下执行的，然后遇到异步的方法的时候，再去进行一些处理，这个异步处理的机制就是要去了解的Event loop。</p>
<p>在JS执行过程中，浏览器分配堆内存去存储数据，而JS方法的执行上下文（调用栈）则是如同其名，是用栈结构存储的。</p>
<p>在浏览器JS执行的过程中，遵守一种策略：</p>
<ol>
<li>执行栈里面的任务，遇到异步的任务，先交给对应的线程去处理</li>
<li>执行完栈内的任务后，询问事件触发线程，是否有新的回调（来自多处）可执行，有的话，执行栈被重新添加任务执行</li>
<li>重复1-2步</li>
</ol>
<h1 id="那什么是宏任务、什么是微任务呢？"><a href="#那什么是宏任务、什么是微任务呢？" class="headerlink" title="那什么是宏任务、什么是微任务呢？"></a>那什么是宏任务、什么是微任务呢？</h1><p>我觉得说这两个之前，得先解释一下浏览器的JS引擎线程跟GUI线程之间的执行顺序先。上面提到这两个线程是互斥的，那么就有一个机制，让他们能够有序地执行。这个机制，就是轮流…对就是这么简单。JS引擎执行完，轮到GUI引擎执行一下，如此往复：JS -&gt; GUI -&gt; JS -&gt; GUI。那么又有新的问题了，JS引擎怎么才叫执行完一次呢？其实就是上面Event loop机制提到的第一步执行完了就算一次执行完。</p>
<p>一个执行栈的同步执行的代码，被认为是<code>宏任务</code>。</p>
<p>eg1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:black'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:red'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:blue'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:grey'</span>;</span><br><span class="line"><span class="comment">// body的颜色只会变一次，因为都是同步的，同一个宏任务内执行完成。</span></span><br><span class="line"><span class="comment">// 去到GUI引擎那里只会认为是要把背景色变成灰色</span></span><br></pre></td></tr></table></figure>

<p>eg2:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:blue'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.style = <span class="string">'background:black'</span></span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="comment">// body背景色先变蓝然后马上变黑</span></span><br><span class="line"><span class="comment">// 说明是分成2次宏任务执行，第一次变蓝，然后GUI执行了，第二次宏任务设置变黑，然后GUI再执行</span></span><br></pre></td></tr></table></figure>

<p>那说完宏任务，<em>什么是微任务</em>?</p>
<p><code>微任务</code>是在宏任务执行指挥立即执行的任务。包括Promise.then process.nextTick</p>
<p>微任务在宏任务和GUI之间执行。所以上面的JS -&gt; GUI -&gt; JS -&gt; GUI流程可以改成：宏任务 -&gt; 微任务 -&gt; GUI -&gt; 宏任务 -&gt; 微任务 -&gt; GUI ···</p>
<p>eg3:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:blue'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.style = <span class="string">'background:black'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 输出1 、 3、 2</span></span><br><span class="line"><span class="comment">// GUI : 背景直接变黑，没有变蓝</span></span><br></pre></td></tr></table></figure>

<p>图示：</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8mN6gy1g6ftkm4jztj30at0gpmxk.jpg" alt="任务流程"></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.im/post/5d5b4c2df265da03dd3d73e5" target="_blank" rel="noopener">从多线程到Event Loop全面梳理</a><br><a href="https://juejin.im/post/5d552275e51d456201486e24" target="_blank" rel="noopener">JS(浏览器)事件环 (宏、微任务)</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/01/types-of-inheritance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Willong lin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/01/types-of-inheritance/" itemprop="url">JS 中的继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-01T23:47:50+08:00">2019-08-01</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在其他 OO 语言当中，接口继承和实现继承。但是 JS 只支持实现继承。JS 的继承通过原型链来实现。</p>
<h1 id="JS-继承的几种方式"><a href="#JS-继承的几种方式" class="headerlink" title="JS 继承的几种方式"></a>JS 继承的几种方式</h1><ol>
<li>原型链继承</li>
<li>借用构造函数</li>
<li>组合继承</li>
<li>原型式继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>
</ol>
<h2 id="一、原型链继承"><a href="#一、原型链继承" class="headerlink" title="一、原型链继承"></a>一、原型链继承</h2><p>【定义】通过将子类的构造函数原型指向父类的实例，来达到继承的目的。</p>
<p>【缺点】</p>
<ol>
<li>构造函数被替换</li>
<li>在子类上挂载方法，要在替换完原型之后，因为整个原型换掉了</li>
<li>父类（父实例）上的引用类型的属性，会被子类的各种实例公用</li>
</ol>
<p>【实例】：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fucntion SuperType () &#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="comment">// instance 从SuperType继承了方法和属性</span></span><br><span class="line">instance.getSuperValue() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="二、借用构造函数继承"><a href="#二、借用构造函数继承" class="headerlink" title="二、借用构造函数继承"></a>二、借用构造函数继承</h2><p>【定义】在子类构造函数的内部调用超类型构造函数。</p>
<p>【缺点】</p>
<ol>
<li>方法都在借用构造函数内声明，不复用</li>
<li>方法都在超类内部，不透明</li>
</ol>
<p>【实例】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">  <span class="comment">// 【缺点】方法们必须写在构造函数里面</span></span><br><span class="line">  <span class="keyword">this</span>.sayColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.color)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将SuperType执行一遍，东西都挂在this上面</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(params)</span><br><span class="line"></span><br><span class="line">instance1.color.push(<span class="string">'black'</span>) <span class="comment">// ['red', 'blue', 'green', 'black']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 各自独立，因为各自用各自的this造的</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(params)</span><br><span class="line"></span><br><span class="line">instance2.color <span class="comment">// ['red', 'blue', 'green']</span></span><br></pre></td></tr></table></figure>

<h2 id="三、组合继承-伪经典继承"><a href="#三、组合继承-伪经典继承" class="headerlink" title="三、组合继承/伪经典继承"></a>三、组合继承/伪经典继承</h2><p>【定义】组合继承，也叫伪经典继承。通过将借用构造函数和原型链两者的技术（优点）组合在一起，用原型链处理属性+方法，用借用构造函数的方法去实现对实例属性的继承。</p>
<p>【优点】</p>
<ol>
<li>用原型链实现对原型属性和方法的继承</li>
<li>通过借用构造函数实现对实例属性的继承</li>
</ol>
<p>【缺点】要执行 2 次超类的构造函数，一次是在构造函数里面，另一次是要生成被子类继承的实力的时候。</p>
<p>【实例】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.color = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>],</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用构造函数，对name属性的继承独立挂载</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指向原型，建造原型链关系</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"><span class="comment">// 重新指定构造函数</span></span><br><span class="line">SubType.prototype.constructor = SubType</span><br><span class="line"><span class="comment">// 重写sayName方法</span></span><br><span class="line">SubType.prototpye.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'Tome'</span>, <span class="number">29</span>)</span><br><span class="line">instance1.color.push(<span class="string">'yellow'</span>)</span><br><span class="line">alert(instance1.color) <span class="comment">// ['red', 'blue', 'black', 'yellow']</span></span><br><span class="line">instance1.sayName() <span class="comment">// Tom</span></span><br><span class="line">instance1.sayAge() <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'Mary'</span>, <span class="number">19</span>)</span><br><span class="line">instance2.color <span class="comment">// ['red', 'blue', 'black']</span></span><br><span class="line">instance2.sayName() <span class="comment">// Mary</span></span><br><span class="line">instance2.sayAge() <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>

<h2 id="四、原型式继承"><a href="#四、原型式继承" class="headerlink" title="四、原型式继承"></a>四、原型式继承</h2><p>【定义】原型可以基于已有的对象创建新的对象。创建一个空的方法，然后将要继承的实例给予空的方法，再用新的方法创建新的实例，就完成了对超类的继承。</p>
<p>【优点】不用创建一个超类的实例去给子类继承。</p>
<p>【缺点】跟原型链继承一样，实际上原型式继承就等于原型链继承的一个马甲。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// o 可以是一个实例或者一个原型，o被所有Object方法创建的饭实例所共享。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、寄生式继承"><a href="#五、寄生式继承" class="headerlink" title="五、寄生式继承"></a>五、寄生式继承</h2><p>【定义】在一个方法内部，借用另一个方法去复制原有的对象，然后对克隆体进行赋值，最后返回克隆体。</p>
<p>【特点】产生的克隆体跟构造函数没什么关系，克隆体是通过内部的方法复制出来的，原型链指向的是本体的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(origin)</span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'tom'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person)</span><br><span class="line">anotherPerson.sayHi() <span class="comment">// tom</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/26/types-of-constructors/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Willong lin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Willong's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/26/types-of-constructors/" itemprop="url">构造函数的发展和种类</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-26T23:51:48+08:00">2019-07-26</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在重新翻阅《Javascript 高级程序设计》，读到了构造函数的种类的发展历程，发现自己之前只是有一个模糊的认识，停留在会用，或者知道怎么用，但是不知道个中原因或者发展历程，没有形成体系化的知识结构，现在借此机会来梳理一下。</p>
<h1 id="创建对象的方法（构造函数种类）"><a href="#创建对象的方法（构造函数种类）" class="headerlink" title="创建对象的方法（构造函数种类）"></a>创建对象的方法（构造函数种类）</h1><ol>
<li>工厂模式</li>
<li>构造函数模式</li>
<li>原型模式</li>
<li>组合模式：构造函数+原型模式</li>
<li>动态原型</li>
<li>寄生构造函数模式</li>
<li>稳妥构造函数模式</li>
</ol>
<h2 id="一、工厂模式"><a href="#一、工厂模式" class="headerlink" title="一、工厂模式"></a>一、工厂模式</h2><p>工厂模式就是很简单的一个function里面生成一个对象，给对象赋予属性和方法之后return出来。</p>
<p>【缺点】生成的对象难以识别是什么类型。也就是说生成出来的东西不知道是什么class。</p>
<p>【示例】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPersion</span>(<span class="params">name, age, gender</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  person.name = name</span><br><span class="line">  person.age = age</span><br><span class="line">  person.gender = gender</span><br><span class="line">  person.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、构造函数模式"><a href="#二、构造函数模式" class="headerlink" title="二、构造函数模式"></a>二、构造函数模式</h2><p>为了解决工厂模式的缺点，诞生了构造函数模式。</p>
<p>【原理】由于在JS的世界中，任何function在new操作符操作下，都会成为构造函数，用以创建特定类型的对象。构造函数中如果没有return语句，就会将构造函数的this（运行环境）return出来，如果有return语句的话，则是以return语句返回的内容为准。</p>
<p>new 操作符做了什么？</p>
<ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象</li>
<li>执行构造函数的代码</li>
<li>return新对象</li>
</ol>
<p>其实感觉就是将构造函数做的事情，包裹在new操作符里面做了。</p>
<hr>
<p>【优点】</p>
<ol>
<li>方法内部无需显式创建对象</li>
<li>直接将方法和属性赋值给this</li>
<li>没有return</li>
<li>可以通过实例的（ constructor属性 || isntanceof方法better ）来判断对象类型<ol>
<li>通过instanceof方法，判断只要是实例中包含的继承过的类的都算true</li>
</ol>
</li>
</ol>
<p>【缺点】构造函数中的方法，会重复生成，每生成一个实例都会生成一堆对应的方法，而且互不相等。在下面的例子中，Tom和Li Lei都有sayHi方法，虽然做的都是一样的事情，但是都各自生成了一个。会造成浪费。</p>
<p>缺点的丑陋解决办法，将方法都挂在共享的作用域下，去读取，但是没有形成封装性。详见示例2。</p>
<p>【示例】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = gender</span><br><span class="line">  <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>, <span class="number">16</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Li Lei'</span>, <span class="number">18</span>, <span class="string">'male'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayHi === persion2.sayHi) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样执行的话Mary等属性会在window下，因为Person执行的时候this在window上</span></span><br><span class="line">Person(<span class="string">'mary'</span>, <span class="number">26</span>, <span class="string">'female'</span>)</span><br></pre></td></tr></table></figure>

<p>【示例2】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【缺点】的丑陋解决办法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = gender</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用挂在全局的共享方法，但是方法一多怎么办？</span></span><br><span class="line">  <span class="keyword">this</span>.sayHi = sayHi</span><br><span class="line">  <span class="keyword">this</span>.sayHi2 = sayHi2</span><br><span class="line">  <span class="keyword">this</span>.sayHi3 = sayHi3</span><br><span class="line">  <span class="comment">// ....无穷无尽，代码也丑陋......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、原型继承"><a href="#三、原型继承" class="headerlink" title="三、原型继承"></a>三、原型继承</h2><p>【原理】原型继承的思想就是将属性和方法都挂载在构造函数的prototype对象上，这个对象的作用就是包含这个构造函数的类型的所有共享属性和方法。其实名字叫“原型”已经挺好理解了，就是所有实例的一个母版，原型上有的，实例都有。</p>
<p><em>了解原型继承需要对原型和原型链有所了解，这个段落不做介绍，日后写一个文章专门说明。</em></p>
<p>【优点】封装在一起，可读性比较好，方法都可以共用。能设置默认值（书中认为是一个缺点，看各人理解吧）。</p>
<p>【缺点】prototype上挂载的属性或者方法，是所有实例所共享的。一旦其中示例中的一个引用类型被进行了修改，那么所有其他实例中的值也会被改动到（引用类型都是指针）。</p>
<p>【实例】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'Tom'</span></span><br><span class="line">Person.prototype.age = <span class="number">18</span></span><br><span class="line">Person.prototype.gender = <span class="string">'male'</span></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person1.name) <span class="comment">// 'Tom'</span></span><br></pre></td></tr></table></figure>

<h2 id="四、组合模式：构造函数-原型模式"><a href="#四、组合模式：构造函数-原型模式" class="headerlink" title="四、组合模式：构造函数+原型模式"></a>四、组合模式：构造函数+原型模式</h2><p>组合继承很好理解，就是取构造函数模式和原型模式的优点作为类的一个构造模式，由于取了两种模式的优点，所以叫组合继承。</p>
<ul>
<li>属性，由构造函数模式处理。</li>
<li>方法，由原型模式处理。</li>
</ul>
<p>【优点】封装化（从前端角度看）。属性独立，方法公用。</p>
<p>【缺点】属性和方法分开声明，不是在同一个方法包裹（从其他OO语言角度）。</p>
<p>【实例】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = gender</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>, <span class="number">16</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Li Lei'</span>, <span class="number">18</span>, <span class="string">'male'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayHi === persion2.sayHi) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="五、动态原型"><a href="#五、动态原型" class="headerlink" title="五、动态原型"></a>五、动态原型</h2><p>动态原型是在组合模式上进行了一点小“优化”</p>
<p>【优点】优化封装。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = gender</span><br><span class="line">  <span class="comment">// 这里判断条件是一个必须会有的方法就行，不用每个都判断</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayHi !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 开始给原型赋值方法们</span></span><br><span class="line">    Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、寄生构造函数模式"><a href="#六、寄生构造函数模式" class="headerlink" title="六、寄生构造函数模式"></a>六、寄生构造函数模式</h2><p>《高程》提到如果上面的模式都不适用的时候，可以使用寄生构造函数模式，但是我暂时没想到什么场景下有这样的需求。</p>
<p>【区别】为什么要专门说一下区别，因为这个跟构造函数模式太像了。但是构造函数是直接造一个对象，且对象为this，而寄生构造模式是自己内部新建一个对象（实际上做了new关键字做的事）。外部再new它其实只是为了挂constructor在实例上面而已。</p>
<p>【特点】<code>说不上优点还是缺点，只能说是特点</code>：寄生构造生产的实例，跟这个构造函数本身是没什么关联的，除了名义上是它的实例之外，其余那些属性和方法都是自己在内部生成和挂载的，跟我们声明和调用那个构造函数（和其原型也）没什么关系。</p>
<p>【实例】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age</span><br><span class="line">  o.gender = gender</span><br><span class="line">  <span class="keyword">return</span> o <span class="comment">// return 的是自己内部new的实例，外面new操作符给的this，没用到。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>, <span class="number">16</span>, <span class="string">'male'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="七、稳妥构造函数模式"><a href="#七、稳妥构造函数模式" class="headerlink" title="七、稳妥构造函数模式"></a>七、稳妥构造函数模式</h2><p>稳妥构造模式在寄生构造模式的基础上，创建实例的时候去掉了new操作符。</p>
<p>【特点】没有公共属性，方法内部不引用this对象。适合在安全的环境中（禁用this和new）</p>
<p>【实例】</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age</span><br><span class="line">  o.gender = gender</span><br><span class="line"></span><br><span class="line">  o.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name) <span class="comment">// 【特点】没有使用this引用值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = Person(<span class="string">'tom'</span>, <span class="number">18</span>, <span class="string">'male'</span>) <span class="comment">// 【特点】不使用new</span></span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Willong lin</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Willong lin</span>

  

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.0.0</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
