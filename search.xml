<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>http协议的缓存</title>
      <link href="/2019/10/03/http-cache/"/>
      <url>/2019/10/03/http-cache/</url>
      
        <content type="html"><![CDATA[<p>之前一次面试被问到这方面的问题，对这方面进行了一次整理。废话不多说，直接列大纲。</p><ol><li>前提：HTTP结构</li><li>缓存规则</li><li>缓存类型</li><li>强制缓存</li><li>对比缓存</li></ol><h1 id="前提：HTTP结构"><a href="#前提：HTTP结构" class="headerlink" title="前提：HTTP结构"></a>前提：HTTP结构</h1><p>HTTP请求，由请求头和请求体部分，请求体就是请求返回的我们要用的东西，请求头就是一些类似于配置的信息。</p><h1 id="缓存规则-流程"><a href="#缓存规则-流程" class="headerlink" title="缓存规则/流程"></a>缓存规则/流程</h1><p>浏览器内部有一个管理缓存的地方和对应的流程和规则，先按照网上的说法定义为浏览器的缓存数据库。</p><p>初次请求的时候，查询数据库，数据库返回没有数据，浏览器发起请求给浏览器，浏览器返回数据，将数据和缓存规则写入缓存系统<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7l4q33x3xj30b7091gm6.jpg" alt="初次请求"></p><p>下面是查询缓存数据库的时候发现强缓存规则时调用的规则和没有命中强缓存规则的流程。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7l4tgga10j30o1098q42.jpg" alt="强缓存规则"></p><p>下面是查询缓存数据库的时候发现对比缓存规则时调用的规则和没有命中强缓存规则的流程。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7l4xt1egtj30qb09g75u.jpg" alt="对比缓存规则"></p><ol><li>发起请求，查询缓存仓库<ol><li>有缓存，查询是否过期</li><li>没有缓存，发起请求，</li></ol></li><li>查询缓存是否过期<ol><li>没过期，走强制缓存路线</li><li>已经过期，查Etag</li></ol></li><li>Etag是否匹配<ol><li>过期了</li></ol></li></ol><h1 id="缓存类型："><a href="#缓存类型：" class="headerlink" title="缓存类型："></a>缓存类型：</h1><ul><li>强制缓存<ul><li>cache-control</li><li>expires</li></ul></li><li>对比缓存<ul><li>last-Modified/If-Modified-Since</li><li>Etag/if-None-Match</li></ul></li></ul><h1 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h1><p>强制缓存通过http请求的header部分标识，分别是Expires字段和Cache-control字段，下面来介绍一下这两者的作用。</p><h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><p>Expires标识服务端返回的到期时间，在这个到期时间之前，资源都可以使用缓存，不用再问服务端索取。</p><p>Expires属性属于HTTP1.0的属性，现在浏览器默认都是HTTP1.1版本的协议，所以作用基本上已经可以忽略不计。</p><p>另外就是Expires的时间是服务器时间，如果客户端的时间跟服务端时间不同步，那么Expires基本上就跪了。比如我把电脑上的时间设置成10年后，那么无论我发送什么请求，都是缓存不了的，因为在我的客户端看来所有资源都是过期的。</p><h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p>Cache-Control是强制缓存当前最常用的属性。上面说到Expires的服务器时间引起的过期问题，那就是说绝对时间不行，所以Cache-Control就改进了这一点，使用了相对时间。</p><p>Cache-Control的属性：</p><ul><li>private：客户端可以缓存</li><li>public：客户端和代理服务器都可以缓存</li><li>max-age=xxx：资源在xxx秒后失效</li><li>no-cache：使用<em>对比缓存</em>来验证缓存数据</li><li>no-store：所有内容都不进行任何形式的缓存</li></ul><h1 id="对比缓存"><a href="#对比缓存" class="headerlink" title="对比缓存"></a>对比缓存</h1><p>什么是对比缓存：需要进行比较判断是否可以使用缓存。通俗地说，就是问下服务器，我能不能使用我本地的这一份缓存，如果可以就返回个304，不行就返回个200.</p><p>那问题来了，怎么去做这个问一下服务器的事情呢？主要就是依赖 Last-Modified/If-Modified-Since，E-tag/if-None-Match，这两块属性。</p><h2 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h2><p>Last-Modified(返回)：是服务器告诉浏览器，这个资源最后的修改时间。下次浏览器请求同一个资源的时候，会将这个资源的Last-Modified用If-Modified-Since的字段告诉服务器，服务器通过对比这个资源的最后修改时间，如果还是在Last-Modified的那个时间，那么就返回304告诉浏览器使用缓存。</p><p>If-Modified-Since（带过去）：告诉服务器，服务器返回的资源最后的修改时间。</p><h2 id="E-tag-If-None-Match"><a href="#E-tag-If-None-Match" class="headerlink" title="E-tag/If-None-Match"></a>E-tag/If-None-Match</h2><p>E-tag（返回）：服务器响应的时候，告诉浏览器在副武器的唯一标识，标识的生成规则由服务器决定。</p><p>If-None-Match（带过去）：请求服务器时，以If-None-Match将E-tag的内容带过去。服务器收到If-None-Match的字段之后，对服务器资源进行标识比对，如果没有匹配的话，则返回200，有匹配的话就返回304.</p>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how-vue-work</title>
      <link href="/2019/08/28/how-vue-work/"/>
      <url>/2019/08/28/how-vue-work/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JS中的setTimeout和promise是怎么回事？详解event loop机制</title>
      <link href="/2019/08/28/eventloop/"/>
      <url>/2019/08/28/eventloop/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在说内容之前，先发一道面试题，内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例题1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><p>这个题目比较简单，应该能够看出来结果是：script start -&gt; script end -&gt; promise1 -&gt; promise2 -&gt; setTimeout</p><p>那为什么是这个顺序呢，结合一些网上的文章，我尝试用自己的理解或者说法去记录这个知识点。</p><h1 id="浏览器内核渲染进程介绍"><a href="#浏览器内核渲染进程介绍" class="headerlink" title="浏览器内核渲染进程介绍"></a>浏览器内核渲染进程介绍</h1><p>在浏览器的每一个Tab，都被认为是一个渲染进程，渲染进程内部分为多个线程，这多个线程之间相合作，各自管理着各自专注的领域的事情：</p><ol><li>GUI渲染线程<ul><li>渲染页面，计算布局和绘制样式</li><li>重绘和回流时会执行</li><li>和JS引擎线程互斥 （防止结果混乱不可预期）</li></ul></li><li>JS引擎线程<ul><li>解析和执行JS代码</li><li>单线程</li><li>和GUI渲染互斥（防止结果混乱不可预期）</li></ul></li><li>事件触发线程<ul><li>管理事件的循环，鼠标点击/滚动、setTimeout、ajax</li><li>在达到条件时，将回调方法放入JS引擎的执行队列</li></ul></li><li>定时器触发线程<ul><li>setTimeout和setInterval的管理线程</li><li>定时任务由定时器触发线程计时（如果定时器不多的页面，这个线程岂不是很空闲）</li><li>当计时完毕，通知事件触发线程</li></ul></li><li>异步http请求线程<ul><li>发起和处理异步请求的线程</li><li>当请求完成，有回调时，通知事件触发线程干活</li></ul></li></ol><h1 id="Event-loop机制介绍"><a href="#Event-loop机制介绍" class="headerlink" title="Event loop机制介绍"></a>Event loop机制介绍</h1><p><img src="http://ww3.sinaimg.cn/large/006y8mN6gy1g6frdhv7ecj30k00bmmxw.jpg" alt="Eventloop 介绍"></p><p>首先我们要明确一个点，JS是从上而下执行的，然后遇到异步的方法的时候，再去进行一些处理，这个异步处理的机制就是要去了解的Event loop。</p><p>在JS执行过程中，浏览器分配堆内存去存储数据，而JS方法的执行上下文（调用栈）则是如同其名，是用栈结构存储的。</p><p>在浏览器JS执行的过程中，遵守一种策略：</p><ol><li>执行栈里面的任务，遇到异步的任务，先交给对应的线程去处理</li><li>执行完栈内的任务后，询问事件触发线程，是否有新的回调（来自多处）可执行，有的话，执行栈被重新添加任务执行</li><li>重复1-2步</li></ol><h1 id="那什么是宏任务、什么是微任务呢？"><a href="#那什么是宏任务、什么是微任务呢？" class="headerlink" title="那什么是宏任务、什么是微任务呢？"></a>那什么是宏任务、什么是微任务呢？</h1><p>我觉得说这两个之前，得先解释一下浏览器的JS引擎线程跟GUI线程之间的执行顺序先。上面提到这两个线程是互斥的，那么就有一个机制，让他们能够有序地执行。这个机制，就是轮流…对就是这么简单。JS引擎执行完，轮到GUI引擎执行一下，如此往复：JS -&gt; GUI -&gt; JS -&gt; GUI。那么又有新的问题了，JS引擎怎么才叫执行完一次呢？其实就是上面Event loop机制提到的第一步执行完了就算一次执行完。</p><p>一个执行栈的同步执行的代码，被认为是<code>宏任务</code>。</p><p>eg1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:black'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:red'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:blue'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:grey'</span>;</span><br><span class="line"><span class="comment">// body的颜色只会变一次，因为都是同步的，同一个宏任务内执行完成。</span></span><br><span class="line"><span class="comment">// 去到GUI引擎那里只会认为是要把背景色变成灰色</span></span><br></pre></td></tr></table></figure><p>eg2:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:blue'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.style = <span class="string">'background:black'</span></span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="comment">// body背景色先变蓝然后马上变黑</span></span><br><span class="line"><span class="comment">// 说明是分成2次宏任务执行，第一次变蓝，然后GUI执行了，第二次宏任务设置变黑，然后GUI再执行</span></span><br></pre></td></tr></table></figure><p>那说完宏任务，<em>什么是微任务</em>?</p><p><code>微任务</code>是在宏任务执行指挥立即执行的任务。包括Promise.then process.nextTick</p><p>微任务在宏任务和GUI之间执行。所以上面的JS -&gt; GUI -&gt; JS -&gt; GUI流程可以改成：宏任务 -&gt; 微任务 -&gt; GUI -&gt; 宏任务 -&gt; 微任务 -&gt; GUI ···</p><p>eg3:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.style = <span class="string">'background:blue'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.style = <span class="string">'background:black'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 输出1 、 3、 2</span></span><br><span class="line"><span class="comment">// GUI : 背景直接变黑，没有变蓝</span></span><br></pre></td></tr></table></figure><p>图示：</p><p><img src="http://ww2.sinaimg.cn/large/006y8mN6gy1g6ftkm4jztj30at0gpmxk.jpg" alt="任务流程"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.im/post/5d5b4c2df265da03dd3d73e5" target="_blank" rel="noopener">从多线程到Event Loop全面梳理</a><br><a href="https://juejin.im/post/5d552275e51d456201486e24" target="_blank" rel="noopener">JS(浏览器)事件环 (宏、微任务)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 中的继承</title>
      <link href="/2019/08/01/types-of-inheritance/"/>
      <url>/2019/08/01/types-of-inheritance/</url>
      
        <content type="html"><![CDATA[<p>在其他 OO 语言当中，接口继承和实现继承。但是 JS 只支持实现继承。JS 的继承通过原型链来实现。</p><h1 id="JS-继承的几种方式"><a href="#JS-继承的几种方式" class="headerlink" title="JS 继承的几种方式"></a>JS 继承的几种方式</h1><ol><li>原型链继承</li><li>借用构造函数</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合式继承</li></ol><h2 id="一、原型链继承"><a href="#一、原型链继承" class="headerlink" title="一、原型链继承"></a>一、原型链继承</h2><p>【定义】通过将子类的构造函数原型指向父类的实例，来达到继承的目的。</p><p>【缺点】</p><ol><li>构造函数被替换</li><li>在子类上挂载方法，要在替换完原型之后，因为整个原型换掉了</li><li>父类（父实例）上的引用类型的属性，会被子类的各种实例公用</li></ol><p>【实例】：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fucntion SuperType () &#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="comment">// instance 从SuperType继承了方法和属性</span></span><br><span class="line">instance.getSuperValue() <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="二、借用构造函数继承"><a href="#二、借用构造函数继承" class="headerlink" title="二、借用构造函数继承"></a>二、借用构造函数继承</h2><p>【定义】在子类构造函数的内部调用超类型构造函数。</p><p>【缺点】</p><ol><li>方法都在借用构造函数内声明，不复用</li><li>方法都在超类内部，不透明</li></ol><p>【实例】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">  <span class="comment">// 【缺点】方法们必须写在构造函数里面</span></span><br><span class="line">  <span class="keyword">this</span>.sayColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.color)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将SuperType执行一遍，东西都挂在this上面</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(params)</span><br><span class="line"></span><br><span class="line">instance1.color.push(<span class="string">'black'</span>) <span class="comment">// ['red', 'blue', 'green', 'black']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 各自独立，因为各自用各自的this造的</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(params)</span><br><span class="line"></span><br><span class="line">instance2.color <span class="comment">// ['red', 'blue', 'green']</span></span><br></pre></td></tr></table></figure><h2 id="三、组合继承-伪经典继承"><a href="#三、组合继承-伪经典继承" class="headerlink" title="三、组合继承/伪经典继承"></a>三、组合继承/伪经典继承</h2><p>【定义】组合继承，也叫伪经典继承。通过将借用构造函数和原型链两者的技术（优点）组合在一起，用原型链处理属性+方法，用借用构造函数的方法去实现对实例属性的继承。</p><p>【优点】</p><ol><li>用原型链实现对原型属性和方法的继承</li><li>通过借用构造函数实现对实例属性的继承</li></ol><p>【缺点】要执行 2 次超类的构造函数，一次是在构造函数里面，另一次是要生成被子类继承的实力的时候。</p><p>【实例】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.color = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>],</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 借用构造函数，对name属性的继承独立挂载</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指向原型，建造原型链关系</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line"><span class="comment">// 重新指定构造函数</span></span><br><span class="line">SubType.prototype.constructor = SubType</span><br><span class="line"><span class="comment">// 重写sayName方法</span></span><br><span class="line">SubType.prototpye.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">'Tome'</span>, <span class="number">29</span>)</span><br><span class="line">instance1.color.push(<span class="string">'yellow'</span>)</span><br><span class="line">alert(instance1.color) <span class="comment">// ['red', 'blue', 'black', 'yellow']</span></span><br><span class="line">instance1.sayName() <span class="comment">// Tom</span></span><br><span class="line">instance1.sayAge() <span class="comment">// 29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">'Mary'</span>, <span class="number">19</span>)</span><br><span class="line">instance2.color <span class="comment">// ['red', 'blue', 'black']</span></span><br><span class="line">instance2.sayName() <span class="comment">// Mary</span></span><br><span class="line">instance2.sayAge() <span class="comment">// 19</span></span><br></pre></td></tr></table></figure><h2 id="四、原型式继承"><a href="#四、原型式继承" class="headerlink" title="四、原型式继承"></a>四、原型式继承</h2><p>【定义】原型可以基于已有的对象创建新的对象。创建一个空的方法，然后将要继承的实例给予空的方法，再用新的方法创建新的实例，就完成了对超类的继承。</p><p>【优点】不用创建一个超类的实例去给子类继承。</p><p>【缺点】跟原型链继承一样，实际上原型式继承就等于原型链继承的一个马甲。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// o 可以是一个实例或者一个原型，o被所有Object方法创建的饭实例所共享。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、寄生式继承"><a href="#五、寄生式继承" class="headerlink" title="五、寄生式继承"></a>五、寄生式继承</h2><p>【定义】在一个方法内部，借用另一个方法去复制原有的对象，然后对克隆体进行赋值，最后返回克隆体。</p><p>【特点】产生的克隆体跟构造函数没什么关系，克隆体是通过内部的方法复制出来的，原型链指向的是本体的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = object(origin)</span><br><span class="line">  clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'tom'</span>,</span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person)</span><br><span class="line">anotherPerson.sayHi() <span class="comment">// tom</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造函数的发展和种类</title>
      <link href="/2019/07/26/types-of-constructors/"/>
      <url>/2019/07/26/types-of-constructors/</url>
      
        <content type="html"><![CDATA[<p>最近在重新翻阅《Javascript 高级程序设计》，读到了构造函数的种类的发展历程，发现自己之前只是有一个模糊的认识，停留在会用，或者知道怎么用，但是不知道个中原因或者发展历程，没有形成体系化的知识结构，现在借此机会来梳理一下。</p><h1 id="创建对象的方法（构造函数种类）"><a href="#创建对象的方法（构造函数种类）" class="headerlink" title="创建对象的方法（构造函数种类）"></a>创建对象的方法（构造函数种类）</h1><ol><li>工厂模式</li><li>构造函数模式</li><li>原型模式</li><li>组合模式：构造函数+原型模式</li><li>动态原型</li><li>寄生构造函数模式</li><li>稳妥构造函数模式</li></ol><h2 id="一、工厂模式"><a href="#一、工厂模式" class="headerlink" title="一、工厂模式"></a>一、工厂模式</h2><p>工厂模式就是很简单的一个function里面生成一个对象，给对象赋予属性和方法之后return出来。</p><p>【缺点】生成的对象难以识别是什么类型。也就是说生成出来的东西不知道是什么class。</p><p>【示例】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPersion</span>(<span class="params">name, age, gender</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  person.name = name</span><br><span class="line">  person.age = age</span><br><span class="line">  person.gender = gender</span><br><span class="line">  person.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、构造函数模式"><a href="#二、构造函数模式" class="headerlink" title="二、构造函数模式"></a>二、构造函数模式</h2><p>为了解决工厂模式的缺点，诞生了构造函数模式。</p><p>【原理】由于在JS的世界中，任何function在new操作符操作下，都会成为构造函数，用以创建特定类型的对象。构造函数中如果没有return语句，就会将构造函数的this（运行环境）return出来，如果有return语句的话，则是以return语句返回的内容为准。</p><p>new 操作符做了什么？</p><ol><li>创建一个新对象</li><li>将构造函数的作用域赋给新对象</li><li>执行构造函数的代码</li><li>return新对象</li></ol><p>其实感觉就是将构造函数做的事情，包裹在new操作符里面做了。</p><hr><p>【优点】</p><ol><li>方法内部无需显式创建对象</li><li>直接将方法和属性赋值给this</li><li>没有return</li><li>可以通过实例的（ constructor属性 || isntanceof方法better ）来判断对象类型<ol><li>通过instanceof方法，判断只要是实例中包含的继承过的类的都算true</li></ol></li></ol><p>【缺点】构造函数中的方法，会重复生成，每生成一个实例都会生成一堆对应的方法，而且互不相等。在下面的例子中，Tom和Li Lei都有sayHi方法，虽然做的都是一样的事情，但是都各自生成了一个。会造成浪费。</p><p>缺点的丑陋解决办法，将方法都挂在共享的作用域下，去读取，但是没有形成封装性。详见示例2。</p><p>【示例】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = gender</span><br><span class="line">  <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>, <span class="number">16</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Li Lei'</span>, <span class="number">18</span>, <span class="string">'male'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayHi === persion2.sayHi) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样执行的话Mary等属性会在window下，因为Person执行的时候this在window上</span></span><br><span class="line">Person(<span class="string">'mary'</span>, <span class="number">26</span>, <span class="string">'female'</span>)</span><br></pre></td></tr></table></figure><p>【示例2】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【缺点】的丑陋解决办法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = gender</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用挂在全局的共享方法，但是方法一多怎么办？</span></span><br><span class="line">  <span class="keyword">this</span>.sayHi = sayHi</span><br><span class="line">  <span class="keyword">this</span>.sayHi2 = sayHi2</span><br><span class="line">  <span class="keyword">this</span>.sayHi3 = sayHi3</span><br><span class="line">  <span class="comment">// ....无穷无尽，代码也丑陋......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、原型继承"><a href="#三、原型继承" class="headerlink" title="三、原型继承"></a>三、原型继承</h2><p>【原理】原型继承的思想就是将属性和方法都挂载在构造函数的prototype对象上，这个对象的作用就是包含这个构造函数的类型的所有共享属性和方法。其实名字叫“原型”已经挺好理解了，就是所有实例的一个母版，原型上有的，实例都有。</p><p><em>了解原型继承需要对原型和原型链有所了解，这个段落不做介绍，日后写一个文章专门说明。</em></p><p>【优点】封装在一起，可读性比较好，方法都可以共用。能设置默认值（书中认为是一个缺点，看各人理解吧）。</p><p>【缺点】prototype上挂载的属性或者方法，是所有实例所共享的。一旦其中示例中的一个引用类型被进行了修改，那么所有其他实例中的值也会被改动到（引用类型都是指针）。</p><p>【实例】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'Tom'</span></span><br><span class="line">Person.prototype.age = <span class="number">18</span></span><br><span class="line">Person.prototype.gender = <span class="string">'male'</span></span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person1.name) <span class="comment">// 'Tom'</span></span><br></pre></td></tr></table></figure><h2 id="四、组合模式：构造函数-原型模式"><a href="#四、组合模式：构造函数-原型模式" class="headerlink" title="四、组合模式：构造函数+原型模式"></a>四、组合模式：构造函数+原型模式</h2><p>组合继承很好理解，就是取构造函数模式和原型模式的优点作为类的一个构造模式，由于取了两种模式的优点，所以叫组合继承。</p><ul><li>属性，由构造函数模式处理。</li><li>方法，由原型模式处理。</li></ul><p>【优点】封装化（从前端角度看）。属性独立，方法公用。</p><p>【缺点】属性和方法分开声明，不是在同一个方法包裹（从其他OO语言角度）。</p><p>【实例】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = gender</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>, <span class="number">16</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">'Li Lei'</span>, <span class="number">18</span>, <span class="string">'male'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayHi === persion2.sayHi) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="五、动态原型"><a href="#五、动态原型" class="headerlink" title="五、动态原型"></a>五、动态原型</h2><p>动态原型是在组合模式上进行了一点小“优化”</p><p>【优点】优化封装。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = gender</span><br><span class="line">  <span class="comment">// 这里判断条件是一个必须会有的方法就行，不用每个都判断</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayHi !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="comment">// 开始给原型赋值方法们</span></span><br><span class="line">    Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、寄生构造函数模式"><a href="#六、寄生构造函数模式" class="headerlink" title="六、寄生构造函数模式"></a>六、寄生构造函数模式</h2><p>《高程》提到如果上面的模式都不适用的时候，可以使用寄生构造函数模式，但是我暂时没想到什么场景下有这样的需求。</p><p>【区别】为什么要专门说一下区别，因为这个跟构造函数模式太像了。但是构造函数是直接造一个对象，且对象为this，而寄生构造模式是自己内部新建一个对象（实际上做了new关键字做的事）。外部再new它其实只是为了挂constructor在实例上面而已。</p><p>【特点】<code>说不上优点还是缺点，只能说是特点</code>：寄生构造生产的实例，跟这个构造函数本身是没什么关联的，除了名义上是它的实例之外，其余那些属性和方法都是自己在内部生成和挂载的，跟我们声明和调用那个构造函数（和其原型也）没什么关系。</p><p>【实例】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age</span><br><span class="line">  o.gender = gender</span><br><span class="line">  <span class="keyword">return</span> o <span class="comment">// return 的是自己内部new的实例，外面new操作符给的this，没用到。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Tom'</span>, <span class="number">16</span>, <span class="string">'male'</span>)</span><br></pre></td></tr></table></figure><h2 id="七、稳妥构造函数模式"><a href="#七、稳妥构造函数模式" class="headerlink" title="七、稳妥构造函数模式"></a>七、稳妥构造函数模式</h2><p>稳妥构造模式在寄生构造模式的基础上，创建实例的时候去掉了new操作符。</p><p>【特点】没有公共属性，方法内部不引用this对象。适合在安全的环境中（禁用this和new）</p><p>【实例】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age</span><br><span class="line">  o.gender = gender</span><br><span class="line"></span><br><span class="line">  o.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name) <span class="comment">// 【特点】没有使用this引用值</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = Person(<span class="string">'tom'</span>, <span class="number">18</span>, <span class="string">'male'</span>) <span class="comment">// 【特点】不使用new</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-wechat-title使用注意事项</title>
      <link href="/2019/07/24/vue-wechat-title/"/>
      <url>/2019/07/24/vue-wechat-title/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是vue-wechat-title"><a href="#什么是vue-wechat-title" class="headerlink" title="什么是vue-wechat-title"></a>什么是vue-wechat-title</h1><p>vue-wechat-title是一个npm包，用来解决SPA项目在微信下（iOS only？）title不会变化的问题。原理是在SPA路由发生变化的时候，动态插入一个iframe去请求favor.ico，然后去修改document.title，而微信在发现有请求的时候，就会刷新页面的title。借助这一特征，vue-wechat-title 做了这么一件事情，也算是解决了大家的一个痛点。但是我在使用的过程中，也遇到了一些问题，所以记录下来。</p><h1 id="不能“滥用”"><a href="#不能“滥用”" class="headerlink" title="不能“滥用”"></a>不能“滥用”</h1><p>当SPA项目需要使用vue-wechat-title时，正确的使用方法应该是在一个根元素上指定 v-wechat-title=”someThing”，someThing这个地方填写一个computed出来的变量或者其他的响应式数据。而不是在每一个路由Page上都写上一个v-wechat-title。</p><h1 id="为什么不能滥用"><a href="#为什么不能滥用" class="headerlink" title="为什么不能滥用"></a>为什么不能滥用</h1><p>现在官方文档好像已经写了我上面那样的用法，但是其实我之前有一些项目有“滥用”，但是也没什么问题发生。直到后来：公司有一个App需要嵌套一个SSR的页面，然后我们的SSR在client阶段“滥用”了v-wechat-title，结果造成了页面在刷新的时候，vue执行会有一个报错：TypeError: undefined is not an object (evaluating ‘n._enterCb’)，通过接入Safari控制台，观察调用栈发现，是vue-wechat-title调用了插入DOM（iframe）之后发生的，之后尝试去掉所有使用v-wechat-ttile的地方后，问题解决。再之后，改成只使用一个v-wechat-title，也没有问题。</p><p>个人猜测，应该是iOS的是webview对多次快速插入这个iframe做了一些限制，导致vue后面的回调异常。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧指南 </tag>
            
            <tag> 微信 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Charles进行抓包调试以及注意事项</title>
      <link href="/2019/07/09/use-charles-proxy/"/>
      <url>/2019/07/09/use-charles-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是抓包"><a href="#什么是抓包" class="headerlink" title="什么是抓包"></a>什么是抓包</h1><p>抓包，就是对某些设备进行正向代理，借此查看其发出的http/https请求。所抓的包就是http请求。抓包一般用于网络调试，观察程序运行状况等情况。抓包工具有很多，比如fiddler、Charles等等。下面以Charles为例进行介绍。</p><h1 id="Charles-的安装与配置"><a href="#Charles-的安装与配置" class="headerlink" title="Charles 的安装与配置"></a>Charles 的安装与配置</h1><p>Charles的安装就比较简单了，一直按下一步就行了。需要注意的是配置，依次点击：（菜单栏）Proxy–Proxy Settings – Proxies<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5bce3trrvj30ww0s2n00.jpg" alt="设置端口号和勾选Enable transparent HTTP proxying"></p><h1 id="Charles-的使用"><a href="#Charles-的使用" class="headerlink" title="Charles 的使用"></a>Charles 的使用</h1><p>当我们需要对网页或者App进行抓包分析的时候，需要先将手机连接上跟电脑同一个局域网，然后打开手机的网络设置-高级-设置代理，IP填写电脑的IP，端口号填上面设置的端口号，一般是8888。然后在手机上操作，就可以看到http的请求了。但是还是看不到https的，因为https是加密过的请求。那我们要看怎么办呢？就需要安装一个证书才行。</p><h1 id="证书安装"><a href="#证书安装" class="headerlink" title="证书安装"></a>证书安装</h1><p>点击 Help - SSL Proxying，可以看到有多个选项，我们一般选择第三个，install Charles Root Certification on a mobile device or a remote broswer，表示在移动设备或者浏览器安装Charles根证书。点击之后，会提示访问 chls.pro/ssl，在不同平台下的设备有不同操作。</p><h2 id="iOS证书安装"><a href="#iOS证书安装" class="headerlink" title="iOS证书安装"></a>iOS证书安装</h2><p>在iOS下，用Safari访问后，会询问是否安装描述文件<br><img src="http://ww1.sinaimg.cn/large/006tNc79gy1g5bcs4aozcj30ku112gpa.jpg" alt></p><p>选择是，然后打开设置-一般设置-描述文件，选择安装<br><img src="http://ww2.sinaimg.cn/large/006tNc79gy1g5bct6q38sj30ku112gnw.jpg" alt></p><p>最后在一般设置-关于本机（拉到最下面）-证书信任设置-选择信任证书就好了<br><img src="http://ww4.sinaimg.cn/large/006tNc79gy1g5bcusarf4j30ku112771.jpg" alt><br><img src="http://ww3.sinaimg.cn/large/006tNc79gy1g5bcvacjyqj30ku1120ux.jpg" alt></p><h2 id="安卓手机证书安装"><a href="#安卓手机证书安装" class="headerlink" title="安卓手机证书安装"></a>安卓手机证书安装</h2><p>安卓手机的话比较麻烦一些，同样是访问 shls.pro/ssl，但是需要使用非原厂浏览器访问，要下载到rem格式的证书文件，不能是crt（crt下载下来安装不了），然后在网络设置，高级选项，选择安装证书，然后去到下载rem证书文件的目录下选择rem文件进行安装。</p><p>我的是小米手机，有这个限制，不知道其他牌子的是不是也一定要rem文件了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧指南 </tag>
            
            <tag> 调试 </tag>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信返回Vue SPA不刷新页面的问题记录</title>
      <link href="/2019/07/07/wechat-backword-refresh/"/>
      <url>/2019/07/07/wechat-backword-refresh/</url>
      
        <content type="html"><![CDATA[<h1 id="问题表现"><a href="#问题表现" class="headerlink" title="问题表现"></a>问题表现</h1><p>在微信内，打开SAP的页面SPA-a，从SPA-a打开外部页面B，从B再返回SPA-a的话，SPA-a页面会呈现Vue数据绑定特征失效的症状，比如load完接口，loading窗口不会根据v-show变化而消失，点击路由跳转SPA，页面也没有出现变化，但实际上路由的hash已经变化了，但是页面内容没有跟着变化。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>本来只是以为是页面loading窗口没有隐藏之类的问题，对loading的值进行核对，观察v-show绑定的值是否有变化，实际上，是有对store里面的loadingSHOW进行赋值的，但template没有变化或者没有进行重新render。</p><h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><blockquote><p><strong>浏览器前进/后退缓存</strong></p><p>这里提到一个概念，浏览器前进/后退缓存(Backward/Forward Cache, BF Cache)，当然也有人叫 disk Cache。<br>BF Cache 是一种浏览器优化， HTML 标准并未指定其如何进行缓存，因此缓存行为是各浏览器各自实现，所以不尽相同。<br>由于不是 HTTP 缓存，所以通过头文件缓存设置 no-cache 是无效的。当然也不能以 HTTP 缓存机制来理解 BF Cache。</p><p>作者：Sakura同志<br>链接：<a href="https://juejin.im/post/5caf3462e51d456e7e297b9e" target="_blank" rel="noopener">https://juejin.im/post/5caf3462e51d456e7e297b9e</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>形成这样的根本原因是微信对于其内置的浏览器进行的“优化”，在iOS下返回SPA-a的时候，微信不会重新请求任何HTML/JS/CSS静态资源，只会把JS重新执行一遍。</p><p>但是按照我的个人理解，JS重新执行一遍，应该也能够形成一样的执行效果才对。实际上的vue整个的生命周期也确实有重新执行，但就是已经失去了双向数据绑定的响应了。</p><p>但实际上表现和期望的不一致，可能是我的理解有偏差。</p><h1 id="问题调试过程"><a href="#问题调试过程" class="headerlink" title="问题调试过程"></a>问题调试过程</h1><ol><li>尝试一：一开始的思路是着重于在返回SPA-a的时候，尝试去刷新SPA-a。由于sessionStorage会计算路由的历史记录count的计数，以此为判断当count等于1（为什么等于1，有另外原因，不在此细说）的时候，尝试使用location.reload()去刷新页面。<ol><li>结果，失败，reaload也没有重新加载页面。</li></ol></li><li>尝试二：由于SPA-a是之前相同业务的迁移，而之前业务并没有出现过这样的情况。通过对比，猜测是由于之前业务是使用动态引入路由页面的，所以对SPA-a的项目进行了相同改造。<ol><li>结果，成功。</li></ol></li></ol><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><ol><li>微信会对之前访问过的页面进行 前进/后退缓存(disk cache)，返回被缓存的页面不会执行静态资源的请求，只会重新执行JS。</li><li>vue SPA在被disk cache之后，返回SPA，不会具备双向绑定的特性。</li><li>第二点可以用异步引入路由组件解决。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧指南 </tag>
            
            <tag> 微信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git submodule使用指南</title>
      <link href="/2019/06/25/git-submodule-usege/"/>
      <url>/2019/06/25/git-submodule-usege/</url>
      
        <content type="html"><![CDATA[<h2 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h2><p>相信任何开发，都会遇到一种情况。在做不同的项目，但是又都会使用到一些常用的方法/组件/代码块等等。<br>作为一个追求优雅的开发人员，肯定不能接受一段代码到处复制粘贴的操作。而且一旦这段代码日后需要更新，到处粘贴的话就需要全局搜索然后含泪修改了。<br>那么有没有一种办法，能够作为一些公共代码的“栖息地”，可以做到一处编写，到处使用呢？</p><h2 id="答案是有的。"><a href="#答案是有的。" class="headerlink" title="答案是有的。"></a><em>答案是有的。</em></h2><h2 id="寻找工具"><a href="#寻找工具" class="headerlink" title="寻找工具"></a>寻找工具</h2><p>经过在知名404网站上一番搜寻，找到了Git内置的一个功能：submodule。</p><h3 id="什么是submodule"><a href="#什么是submodule" class="headerlink" title="什么是submodule"></a>什么是submodule</h3><blockquote><p>有种情况我们经常会遇到：某个工作中的项目需要包含并使用另一个项目。 也许是第三方库，或者你独立开发的，用于多个父项目的库。 现在问题来了：你想要把它们当做两个独立的项目，同时又想在一个项目中使用另一个。</p><p>Git 通过子模块来解决这个问题。 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p></blockquote><hr><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="添加子模块"><a href="#添加子模块" class="headerlink" title="添加子模块"></a>添加子模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 直接clone，会在当前目录生成一个someSubmodule目录存放仓库内容</span><br><span class="line">git submodule add https://github.com/chaconinc/someSubmodule</span><br><span class="line"></span><br><span class="line"># 指定文件目录</span><br><span class="line">git submodule add https://github.com/chaconinc/someSubmodule  src/submodulePath</span><br></pre></td></tr></table></figure><p>新增成功之后，运行<code>git status</code>会在父仓库发现增加了2个变化</p><ol><li>new file:   .gitmodules</li><li>new file:   someSubmodule（实际上并不是一个file）</li></ol><p>展开说说：</p><ol><li><p>什么是.submodules<br>.submodules是记录当前项目的子模块配置的文件，里面保存了项目 URL 与已经拉取的本地目录之间的映射。</p></li><li><p>子模块目录<br>在新增完子模块之后，执行<code>git status</code>之后，会看到类似下面的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached someSubmodule</span><br><span class="line">diff --git a/someSubmodule b/someSubmodule</span><br><span class="line"># 重点是下面这行的 160000</span><br><span class="line">new file mode 160000</span><br><span class="line">index 0000000..c3f01dc</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/DbConnector</span><br><span class="line">@@ -0,0 +1 @@</span><br><span class="line">+Subproject commit c3f01dc8862123d317dd46284b05b6892c7b29bc</span><br></pre></td></tr></table></figure></li></ol><p>虽然someSubmodule是父仓库里面的一个目录，但是Git并不会列出里面所有的变化，而是会当做一个特殊的提交。<br>PS：160000模式。 这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，而非将它记录成一个子目录或者一个文件。</p><h3 id="clone已经包含子模块的项目"><a href="#clone已经包含子模块的项目" class="headerlink" title="clone已经包含子模块的项目"></a>clone已经包含子模块的项目</h3><p>正常clone包含子模块的函数之后，由于.submodule文件的存在someSubmodule已经自动生成。但是里面是空的。还需要执行2个命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 用来初始化本地配置文件</span><br><span class="line">git submodule init</span><br><span class="line"># 从该项目中抓取所有数据并检出父项目中列出的合适的提交(指定的提交)。</span><br><span class="line">git submodule update</span><br><span class="line">------------------更好的方式---------------------</span><br><span class="line"># clone 父仓库的时候加上 --recursive，会自动初始化并更新仓库中的每一个子模块</span><br><span class="line">git clone --recursive https://github.com/chaconinc/MainProject</span><br></pre></td></tr></table></figure><h3 id="git-submodule-工作流"><a href="#git-submodule-工作流" class="headerlink" title="git submodule 工作流"></a>git submodule 工作流</h3><p>当一个项目里面包含子模块的时候，不仅仅需要对父仓库进行版本管理，子模块目录下也是存在版本的。那在不同的父仓库下面如何进行子模块的版本管理也成为新的问题。</p><p>最简单的办法，就是主项目只专注使用子模块的master分支上的版本，而不使用子模块内部的任何分支版本。</p><p>操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd submodulePath</span><br><span class="line">git fetch</span><br><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure><p>此时在主项目就能看到submodule目录已经更新了。<br>当然这也操作有点不方便，下面是更简便的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Git 将会进入子模块然后抓取并更新，默认更新master分支</span><br><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure><p>如果需要更新其他分支的话，需要另外配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将git submodule update --remote 的分支设置为stable分支</span><br><span class="line">git config -f .gitmodules submodule.DbConnector.branch stable</span><br></pre></td></tr></table></figure><hr><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>我个人认为，子模块在使用的过程才是最值得注意的地方，所以也没有跟上面的内容一起作为“增删改查”系列写下去。<br>“改” 我认为是最重要的一环。其中又可以分为：</p><ol><li>对本地的子模块进行修改</li><li>更新他人修改的子模块内容</li></ol><h3 id="对本地的子模块进行修改"><a href="#对本地的子模块进行修改" class="headerlink" title="对本地的子模块进行修改"></a>对本地的子模块进行修改</h3><p>上面提到更新子模块的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure><p>但是此时的子模块是出于一个特殊的状态，虽然上游的变化被更新到了本地，但是本地子模块会处于一个<em>游离的HEAD</em>状态。</p><p>在HEAD状态下，如果将本地修改的内容进行commit，是不会“附着”到任何分支上的。<em>游离的内容，会在切换分支之后消失。</em></p><p><em>那怎么操作才是正确的呢？</em></p><ol><li><p>先进入子模块，然后检出一个分支。</p></li><li><p>再执行commit等本地操作</p></li><li><p>执行<code>git submodule update —remote —merge</code>，将上游的变化合并到本地的这个分支上。如果你忘记—rebase或—merge，Git 会将子模块更新为服务器上的状态。并且会将项目重置为一个游离的 HEAD 状态。要弥补这个错误的话，重新执行1和3就可以了。</p></li><li><p>如果本地的文件跟上游文件出现冲突，则按照普通解决办法解决了再提交就好了。</p></li><li><p>发布改动（推送）：在父仓库执行<code>git push</code>时添加<code>--recure-submodule</code> 参数，此参数表示递归子模块，可以设置为2个值“check”和“on-demand”。check会使没推送子模块的父仓库本身推送失败。而on-demand会尝试自动推送子模块后再推送父仓库，如果子模块由于其他原因失败，那么父仓库也会推送失败。</p></li></ol><h3 id="合并子模块的改动"><a href="#合并子模块的改动" class="headerlink" title="合并子模块的改动"></a>合并子模块的改动</h3><p>根据Gitbook的描述，这是当同一分支在本地和上游出现了不同分叉，需要进行合并的时候，并且二者不是祖先和后代的关系（或者说不是一条分子上的提交）。</p><p>操作方法如下：</p><ol><li>对上游的提交，进行检出分支</li><li>将1检出的分支，合并到本地</li><li>解决冲突</li><li>回到主项目</li><li>检查子模块的记录</li><li>解决子模块冲突</li><li>提交主仓库合并</li></ol><h3 id="一些我个人的理解"><a href="#一些我个人的理解" class="headerlink" title="一些我个人的理解"></a>一些我个人的理解</h3><p>子模块的使用上面说得可能还是有点比较绕，我个人认为比较合适我们团队的子模块工作流应该比较简单。</p><ol><li>主项目需要在自模块上开发新功能时，需要在主项目内的子模块开新分支，然后进行开发</li><li>子模块的代码需要独立提交，形成commit信息记录在主仓库</li><li>由于主项目最终也是需要进行打包的，所以子模块的版本只要是基于master，就认为是可信的</li><li>最后主项目的整个版本经过验证需要上线后，则将子模块的分支合并到子模块的master分支上，那么下一个进行子模块开发的人，就会包含到最新的代码</li></ol><p>参考文档：</p><ol><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">Git - 子模块</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 技巧指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/06/24/hello-world/"/>
      <url>/2019/06/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
